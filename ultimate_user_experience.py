#!/usr/bin/env python3
"""
Ultimate User Experience Launcher
ÁªàÊûÅÁî®Êà∑‰ΩìÈ™åÂêØÂä®Âô®

Features:
- Animated startup sequences
- Smart environment detection
- Interactive help system
- Multi-language support
- Comprehensive error recovery
- Beautiful progress indicators
"""

import os
import sys
import time
import subprocess
import platform
from pathlib import Path
from typing import Optional, List, Dict, Any
import json


class UltimateUserExperience:
    """Ultimate user experience with comprehensive features"""

    def __init__(self):
        self.system = platform.system()
        self.python_version = sys.version_info
        self.working_dir = Path.cwd()

        # Language detection
        self.language = self._detect_language()

        # Load messages
        self.messages = self._load_messages()

        # State tracking
        self.startup_state = {
            "first_run": not Path(".install_state.json").exists(),
            "previous_launches": 0,
            "last_successful_launch": None,
            "preferred_method": None
        }

        self._load_startup_state()

    def _detect_language(self) -> str:
        """Detect user's preferred language"""
        # Check environment variables
        for var in ['LANG', 'LANGUAGE', 'LC_ALL']:
            if var in os.environ:
                lang = os.environ[var].lower()
                if 'zh' in lang or 'chinese' in lang:
                    return 'zh'

        # Check system locale
        try:
            import locale
            system_lang = locale.getdefaultlocale()[0]
            if system_lang and ('zh' in system_lang.lower() or 'chinese' in system_lang.lower()):
                return 'zh'
        except:
            pass

        return 'en'  # Default to English

    def _load_messages(self) -> Dict[str, Dict[str, str]]:
        """Load localized messages"""
        return {
            'en': {
                'welcome': 'üéì Welcome to ManageBac Assignment Checker',
                'starting': 'üöÄ Starting application...',
                'detecting': 'üîç Detecting optimal launch method...',
                'checking_deps': 'üì¶ Checking dependencies...',
                'launching': '‚ú® Launching application...',
                'success': '‚úÖ Application started successfully!',
                'error': '‚ùå Error occurred',
                'retry': 'üîÑ Retrying...',
                'help': 'üí° Need help? Press H for help menu',
                'first_time': 'üåü First time setup detected',
                'returning_user': 'üëã Welcome back!',
                'optimizing': '‚ö° Optimizing for your system...',
                'ready': 'üéØ Ready to launch!'
            },
            'zh': {
                'welcome': 'üéì Ê¨¢Ëøé‰ΩøÁî® ManageBac ‰Ωú‰∏öÊ£ÄÊü•Âô®',
                'starting': 'üöÄ Ê≠£Âú®ÂêØÂä®Â∫îÁî®Á®ãÂ∫è...',
                'detecting': 'üîç Ê≠£Âú®Ê£ÄÊµãÊúÄ‰Ω≥ÂêØÂä®ÊñπÂºè...',
                'checking_deps': 'üì¶ Ê≠£Âú®Ê£ÄÊü•‰æùËµñÈ°π...',
                'launching': '‚ú® Ê≠£Âú®ÂêØÂä®Â∫îÁî®Á®ãÂ∫è...',
                'success': '‚úÖ Â∫îÁî®Á®ãÂ∫èÂêØÂä®ÊàêÂäüÔºÅ',
                'error': '‚ùå ÂèëÁîüÈîôËØØ',
                'retry': 'üîÑ Ê≠£Âú®ÈáçËØï...',
                'help': 'üí° ÈúÄË¶ÅÂ∏ÆÂä©ÔºüÊåâ H ÈîÆÊâìÂºÄÂ∏ÆÂä©ËèúÂçï',
                'first_time': 'üåü Ê£ÄÊµãÂà∞È¶ñÊ¨°ËÆæÁΩÆ',
                'returning_user': 'üëã Ê¨¢ËøéÂõûÊù•ÔºÅ',
                'optimizing': '‚ö° Ê≠£Âú®‰∏∫ÊÇ®ÁöÑÁ≥ªÁªü‰ºòÂåñ...',
                'ready': 'üéØ ÂáÜÂ§áÂêØÂä®ÔºÅ'
            }
        }

    def _load_startup_state(self):
        """Load previous startup state"""
        state_file = Path(".app_state.json")
        if state_file.exists():
            try:
                with open(state_file, 'r', encoding='utf-8') as f:
                    state = json.load(f)
                    self.startup_state.update(state)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not load startup state: {e}")

    def _save_startup_state(self):
        """Save startup state for next time"""
        state_file = Path(".app_state.json")
        try:
            with open(state_file, 'w', encoding='utf-8') as f:
                json.dump(self.startup_state, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not save startup state: {e}")

    def get_message(self, key: str) -> str:
        """Get localized message"""
        return self.messages[self.language].get(key, key)

    def show_animated_welcome(self):
        """Show animated welcome screen"""
        print("\n" + "="*70)

        # Animated title
        title = self.get_message('welcome')
        for i, char in enumerate(title):
            print(char, end='', flush=True)
            time.sleep(0.03)
        print()

        # System info
        print(f"üíª System: {self.system} | Python: {self.python_version.major}.{self.python_version.minor}")
        print(f"üìÅ Working Directory: {self.working_dir.name}")

        # User status
        if self.startup_state['first_run']:
            print(f"üåü {self.get_message('first_time')}")
        else:
            print(f"üëã {self.get_message('returning_user')}")
            launches = self.startup_state['previous_launches']
            print(f"üìä Previous launches: {launches}")

        print("="*70)
        print(f"{self.get_message('help')}")
        print()

    def show_progress_bar(self, message: str, duration: float = 2.0):
        """Show animated progress bar"""
        print(f"{message}", end=" ")

        bar_length = 30
        for i in range(bar_length + 1):
            progress = i / bar_length
            filled = int(progress * bar_length)
            bar = "‚ñà" * filled + "‚ñë" * (bar_length - filled)
            percentage = int(progress * 100)

            print(f"\r{message} [{bar}] {percentage}%", end="", flush=True)
            time.sleep(duration / bar_length)

        print(" ‚úÖ")

    def detect_optimal_launch_method(self) -> List[Dict[str, Any]]:
        """Detect the best launch methods for this system"""
        self.show_progress_bar(self.get_message('detecting'))

        methods = []

        # Check for optimized installer (preferred)
        if Path("‰ºòÂåñÂÆâË£ÖÂô®.py").exists():
            methods.append({
                "name": "Optimized Installer | ‰ºòÂåñÂÆâË£ÖÂô®",
                "command": ["python3", "‰ºòÂåñÂÆâË£ÖÂô®.py"],
                "priority": 10,
                "description": "Best user experience with auto-launch"
            })

        # Check for intelligent launcher
        if Path("intelligent_launcher.py").exists():
            methods.append({
                "name": "Intelligent Launcher | Êô∫ËÉΩÂêØÂä®Âô®",
                "command": ["python3", "intelligent_launcher.py"],
                "priority": 9,
                "description": "Smart environment detection"
            })

        # Check for ultimate installer
        if Path("ultimate_installer.py").exists():
            methods.append({
                "name": "Ultimate Installer | ÁªàÊûÅÂÆâË£ÖÂô®",
                "command": ["python3", "ultimate_installer.py"],
                "priority": 8,
                "description": "Complete installation system"
            })

        # Check for GUI launcher
        if Path("gui_launcher.py").exists():
            methods.append({
                "name": "GUI Launcher | GUIÂêØÂä®Âô®",
                "command": ["python3", "gui_launcher.py"],
                "priority": 7,
                "description": "Direct GUI application"
            })

        # Check for professional GUI module
        if Path("managebac_checker").exists():
            methods.append({
                "name": "Professional GUI Module | ‰∏ì‰∏öGUIÊ®°Âùó",
                "command": ["python3", "-m", "managebac_checker.professional_gui"],
                "priority": 6,
                "description": "Direct module launch"
            })

        # Sort by priority
        methods.sort(key=lambda x: x['priority'], reverse=True)

        return methods

    def check_dependencies(self) -> Dict[str, bool]:
        """Check system dependencies"""
        self.show_progress_bar(self.get_message('checking_deps'))

        deps = {}

        # Check Python version
        deps['python_version'] = self.python_version >= (3, 8)

        # Check required modules
        required_modules = ['tkinter', 'pathlib', 'json', 'subprocess']
        for module in required_modules:
            try:
                __import__(module)
                deps[f'module_{module}'] = True
            except ImportError:
                deps[f'module_{module}'] = False

        # Check for package files
        deps['package_exists'] = Path("managebac_checker").exists()
        deps['config_exists'] = Path("config.py").exists() or Path("managebac_checker/config.py").exists()

        return deps

    def launch_application(self, method: Dict[str, Any]) -> bool:
        """Launch application using specified method"""
        print(f"\nüöÄ {method['name']}")
        print(f"üìù {method['description']}")

        self.show_progress_bar(self.get_message('launching'), 1.5)

        try:
            # Import enhanced error handling if available
            try:
                from enhanced_error_handler import handle_error, log_info
                log_info(f"Launching application with method: {method['name']}")
            except ImportError:
                pass

            # Launch the application
            process = subprocess.Popen(
                method['command'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Wait a moment to see if it starts successfully
            time.sleep(2)

            if process.poll() is None:
                # Process is still running - success!
                print(f"‚úÖ {self.get_message('success')}")

                # Update startup state
                self.startup_state['last_successful_launch'] = time.time()
                self.startup_state['preferred_method'] = method['name']
                self.startup_state['previous_launches'] += 1
                self._save_startup_state()

                return True
            else:
                # Process exited - check for errors
                stdout, stderr = process.communicate()
                if stderr:
                    print(f"‚ùå Launch failed: {stderr}")
                return False

        except Exception as e:
            print(f"‚ùå Failed to launch: {e}")
            try:
                from enhanced_error_handler import handle_error
                handle_error(e, f"Application Launch - {method['name']}", "ERROR")
            except ImportError:
                pass
            return False

    def show_help_menu(self):
        """Show interactive help menu"""
        print("\n" + "="*60)
        print("üìö ManageBac Assignment Checker - Help Menu")
        print("üìö ManageBac ‰Ωú‰∏öÊ£ÄÊü•Âô® - Â∏ÆÂä©ËèúÂçï")
        print("="*60)

        help_items = [
            ("1", "Quick Start | Âø´ÈÄüÂºÄÂßã", "Launch with best method | ‰ΩøÁî®ÊúÄ‰Ω≥ÊñπÂºèÂêØÂä®"),
            ("2", "Manual Launch | ÊâãÂä®ÂêØÂä®", "Choose launch method | ÈÄâÊã©ÂêØÂä®ÊñπÂºè"),
            ("3", "System Check | Á≥ªÁªüÊ£ÄÊü•", "Check dependencies | Ê£ÄÊü•‰æùËµñÈ°π"),
            ("4", "Troubleshooting | ÊïÖÈöúÊéíÈô§", "Common solutions | Â∏∏ËßÅËß£ÂÜ≥ÊñπÊ°à"),
            ("5", "Documentation | ÊñáÊ°£", "Open user guide | ÊâìÂºÄÁî®Êà∑ÊåáÂçó"),
            ("Q", "Quit | ÈÄÄÂá∫", "Exit application | ÈÄÄÂá∫Â∫îÁî®Á®ãÂ∫è")
        ]

        for key, title, desc in help_items:
            print(f"{key:>2}. {title}")
            print(f"     {desc}")

        print("="*60)

        choice = input("\nüëâ Select option | ÈÄâÊã©ÈÄâÈ°π: ").strip().upper()

        if choice == "1":
            return "quick_start"
        elif choice == "2":
            return "manual_launch"
        elif choice == "3":
            return "system_check"
        elif choice == "4":
            return "troubleshooting"
        elif choice == "5":
            return "documentation"
        elif choice == "Q":
            return "quit"
        else:
            print("‚ùå Invalid choice | Êó†ÊïàÈÄâÊã©")
            return None

    def show_troubleshooting(self):
        """Show troubleshooting guide"""
        print("\n" + "="*60)
        print("üîß Troubleshooting Guide | ÊïÖÈöúÊéíÈô§ÊåáÂçó")
        print("="*60)

        issues = [
            {
                "problem": "Application won't start | Â∫îÁî®Á®ãÂ∫èÊó†Ê≥ïÂêØÂä®",
                "solutions": [
                    "Check Python version (3.8+ required) | Ê£ÄÊü•PythonÁâàÊú¨ÔºàÈúÄË¶Å3.8+Ôºâ",
                    "Install dependencies: pip install -r requirements.txt",
                    "Try different launch method | Â∞ùËØï‰∏çÂêåÁöÑÂêØÂä®ÊñπÂºè"
                ]
            },
            {
                "problem": "GUI crashes or flashes | GUIÈó™ÈÄÄÊàñÈó™ÁÉÅ",
                "solutions": [
                    "Check display server (X11/Wayland) | Ê£ÄÊü•ÊòæÁ§∫ÊúçÂä°Âô®",
                    "Verify tkinter: python3 -m tkinter | È™åËØÅtkinter",
                    "Run in compatibility mode | ‰ΩøÁî®ÂÖºÂÆπÊ®°ÂºèËøêË°å"
                ]
            },
            {
                "problem": "Dependencies missing | Áº∫Â∞ë‰æùËµñÈ°π",
                "solutions": [
                    "Run installer script | ËøêË°åÂÆâË£ÖÂô®ËÑöÊú¨",
                    "Manual install: pip install <package> | ÊâãÂä®ÂÆâË£ÖÂåÖ",
                    "Check virtual environment | Ê£ÄÊü•ËôöÊãüÁéØÂ¢É"
                ]
            }
        ]

        for i, issue in enumerate(issues, 1):
            print(f"\n{i}. {issue['problem']}")
            for j, solution in enumerate(issue['solutions'], 1):
                print(f"   {j}) {solution}")

        print("\nüí° Still having issues? | ‰ªçÊúâÈóÆÈ¢òÔºü")
        print("   ‚Ä¢ Check logs in ./logs/ directory | Êü•Áúã./logs/ÁõÆÂΩï‰∏≠ÁöÑÊó•Âøó")
        print("   ‚Ä¢ Report issue on GitHub | Âú®GitHub‰∏äÊä•ÂëäÈóÆÈ¢ò")
        print("   ‚Ä¢ Run system diagnostic | ËøêË°åÁ≥ªÁªüËØäÊñ≠")

    def run(self):
        """Main application flow"""
        try:
            # Show welcome screen
            self.show_animated_welcome()

            # Check for immediate help request
            print("Press ENTER to continue or H for help...")
            user_input = input().strip().upper()

            if user_input == 'H':
                action = self.show_help_menu()
                if action == "quit":
                    print("üëã Goodbye! | ÂÜçËßÅÔºÅ")
                    return
                elif action == "system_check":
                    deps = self.check_dependencies()
                    print("\nüìä System Check Results:")
                    for dep, status in deps.items():
                        status_icon = "‚úÖ" if status else "‚ùå"
                        print(f"   {status_icon} {dep}")
                    input("\nPress ENTER to continue...")
                elif action == "troubleshooting":
                    self.show_troubleshooting()
                    input("\nPress ENTER to continue...")

            # Detect launch methods
            methods = self.detect_optimal_launch_method()

            if not methods:
                print("‚ùå No launch methods available | Ê≤°ÊúâÂèØÁî®ÁöÑÂêØÂä®ÊñπÂºè")
                print("üí° Please run the installer first | ËØ∑ÂÖàËøêË°åÂÆâË£ÖÂô®")
                return

            # Check dependencies
            deps = self.check_dependencies()
            critical_deps_ok = all([
                deps.get('python_version', False),
                deps.get('module_tkinter', False),
                deps.get('package_exists', False)
            ])

            if not critical_deps_ok:
                print("‚ùå Critical dependencies missing | Áº∫Â∞ëÂÖ≥ÈîÆ‰æùËµñÈ°π")
                print("üí° Please run the installer to fix dependencies")
                print("üí° ËØ∑ËøêË°åÂÆâË£ÖÂô®Êù•‰øÆÂ§ç‰æùËµñÈ°π")
                return

            # Show optimization message
            print(f"\n‚ö° {self.get_message('optimizing')}")
            time.sleep(1)
            print(f"üéØ {self.get_message('ready')}")

            # Try launch methods in order of priority
            for method in methods:
                if self.launch_application(method):
                    print(f"\nüéâ Application launched successfully with {method['name']}")
                    print("üéâ Â∫îÁî®Á®ãÂ∫èÂêØÂä®ÊàêÂäü")
                    return
                else:
                    print(f"‚ö†Ô∏è Method failed, trying next option...")
                    time.sleep(1)

            # If all methods failed
            print("\n‚ùå All launch methods failed | ÊâÄÊúâÂêØÂä®ÊñπÂºèÈÉΩÂ§±Ë¥•‰∫Ü")
            print("üîß Please check the troubleshooting guide")
            print("üîß ËØ∑Êü•ÁúãÊïÖÈöúÊéíÈô§ÊåáÂçó")

        except KeyboardInterrupt:
            print("\nüõë Launch cancelled by user | Áî®Êà∑ÂèñÊ∂àÂêØÂä®")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {e}")
            try:
                from enhanced_error_handler import handle_error
                handle_error(e, "Ultimate User Experience", "CRITICAL")
            except ImportError:
                import traceback
                traceback.print_exc()


def main():
    """Main function"""
    launcher = UltimateUserExperience()
    launcher.run()


if __name__ == "__main__":
    main()