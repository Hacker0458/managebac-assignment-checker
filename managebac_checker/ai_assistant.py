#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ü§ñ AI Assistant Module | AIÂä©ÊâãÊ®°Âùó
Enhanced with OpenAI integration for intelligent analysis and suggestions
Â¢ûÂº∫ÁöÑOpenAIÈõÜÊàêÔºåÊèê‰æõÊô∫ËÉΩÂàÜÊûêÂíåÂª∫ËÆÆ
"""

import os
import json
from typing import Dict, List, Optional, Any

# from datetime import datetime  # Unused import
import openai
from .models import Assignment
from .logging_utils import get_logger

logger = get_logger(__name__)


class AIAssistant:
    """AI Assistant for intelligent analysis | Êô∫ËÉΩÂàÜÊûêAIÂä©Êâã"""

    # Bilingual messages | ÂèåËØ≠Ê∂àÊÅØ
    MESSAGES = {
        "en": {
            "init": "ü§ñ Initializing AI Assistant...",
            "enabled": "‚úÖ AI Assistant enabled with API key",
            "disabled": "‚ùå AI Assistant disabled (no API key provided)",
            "analyzing": "üîç Analyzing assignments with AI...",
            "generating": "üí° Generating intelligent suggestions...",
            "error": "‚ùå AI analysis error: {}",
            "no_key": "‚ö†Ô∏è No OpenAI API key provided. AI features disabled.",
            "invalid_key": "‚ùå Invalid OpenAI API key. Please check your configuration.",
            "success": "‚úÖ AI analysis completed successfully",
            "suggestion": "üí° AI Suggestion: {}",
            "priority_advice": "üìä Priority Management Advice",
            "study_plan": "üìö Recommended Study Plan",
            "time_management": "‚è∞ Time Management Tips",
        },
        "zh": {
            "init": "ü§ñ Ê≠£Âú®ÂàùÂßãÂåñAIÂä©Êâã...",
            "enabled": "‚úÖ AIÂä©ÊâãÂ∑≤ÂêØÁî®ÔºàÂ∑≤Êèê‰æõAPIÂØÜÈí•Ôºâ",
            "disabled": "‚ùå AIÂä©ÊâãÂ∑≤Á¶ÅÁî®ÔºàÊú™Êèê‰æõAPIÂØÜÈí•Ôºâ",
            "analyzing": "üîç Ê≠£Âú®‰ΩøÁî®AIÂàÜÊûê‰Ωú‰∏ö...",
            "generating": "üí° Ê≠£Âú®ÁîüÊàêÊô∫ËÉΩÂª∫ËÆÆ...",
            "error": "‚ùå AIÂàÜÊûêÈîôËØØÔºö{}",
            "no_key": "‚ö†Ô∏è Êú™Êèê‰æõOpenAI APIÂØÜÈí•„ÄÇAIÂäüËÉΩÂ∑≤Á¶ÅÁî®„ÄÇ",
            "invalid_key": "‚ùå OpenAI APIÂØÜÈí•Êó†Êïà„ÄÇËØ∑Ê£ÄÊü•ÊÇ®ÁöÑÈÖçÁΩÆ„ÄÇ",
            "success": "‚úÖ AIÂàÜÊûêÊàêÂäüÂÆåÊàê",
            "suggestion": "üí° AIÂª∫ËÆÆÔºö{}",
            "priority_advice": "üìä ‰ºòÂÖàÁ∫ßÁÆ°ÁêÜÂª∫ËÆÆ",
            "study_plan": "üìö Êé®ËçêÂ≠¶‰π†ËÆ°Âàí",
            "time_management": "‚è∞ Êó∂Èó¥ÁÆ°ÁêÜÊäÄÂ∑ß",
        },
    }

    def __init__(
        self,
        api_key: Optional[str] = None,
        language: str = "en",
        enable_ai: bool = True,
        model: str = "gpt-3.5-turbo",
    ):
        """
        Initialize AI Assistant | ÂàùÂßãÂåñAIÂä©Êâã

        Args:
            api_key: OpenAI API key (optional) | OpenAI APIÂØÜÈí•ÔºàÂèØÈÄâÔºâ
            language: Interface language ('en' or 'zh') | ÁïåÈù¢ËØ≠Ë®Ä
            enable_ai: Whether to enable AI features | ÊòØÂê¶ÂêØÁî®AIÂäüËÉΩ
            model: OpenAI model to use | ‰ΩøÁî®ÁöÑOpenAIÊ®°Âûã
        """
        self.language = language
        self.enable_ai = enable_ai
        self.model = model
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.client = None

        self._log("init")

        if self.enable_ai and self.api_key:
            try:
                openai.api_key = self.api_key
                self.client = openai
                self._log("enabled")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
                self._log("invalid_key")
                self.enable_ai = False
        else:
            self._log("disabled" if not self.enable_ai else "no_key")

    def _log(self, key: str, *args):
        """Log bilingual message | ËÆ∞ÂΩïÂèåËØ≠Ê∂àÊÅØ"""
        msg = self.MESSAGES[self.language].get(key, key)
        if args:
            msg = msg.format(*args)
        logger.info(msg)
        return msg

    def analyze_assignments(
        self, assignments: List[Assignment], analysis_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Analyze assignments with AI | ‰ΩøÁî®AIÂàÜÊûê‰Ωú‰∏ö

        Args:
            assignments: List of assignments | ‰Ωú‰∏öÂàóË°®
            analysis_data: Analysis data from analyzer | ÂàÜÊûêÂô®ÁöÑÂàÜÊûêÊï∞ÊçÆ

        Returns:
            AI-enhanced analysis results | AIÂ¢ûÂº∫ÁöÑÂàÜÊûêÁªìÊûú
        """
        if not self.enable_ai or not self.client:
            return {"enabled": False, "message": self._log("disabled")}

        try:
            self._log("analyzing")

            # Prepare assignment data for AI | ‰∏∫AIÂáÜÂ§á‰Ωú‰∏öÊï∞ÊçÆ
            assignment_summary = self._prepare_assignment_summary(
                assignments, analysis_data
            )

            # Generate AI insights | ÁîüÊàêAIÊ¥ûÂØü
            insights = self._generate_insights(assignment_summary)

            # Generate study recommendations | ÁîüÊàêÂ≠¶‰π†Âª∫ËÆÆ
            recommendations = self._generate_recommendations(
                assignment_summary, insights
            )

            # Generate time management plan | ÁîüÊàêÊó∂Èó¥ÁÆ°ÁêÜËÆ°Âàí
            time_plan = self._generate_time_plan(assignments, analysis_data)

            self._log("success")

            return {
                "enabled": True,
                "insights": insights,
                "recommendations": recommendations,
                "time_plan": time_plan,
                "summary": self._generate_summary(insights, recommendations),
                "message": self._log("success"),
            }

        except Exception as e:
            error_msg = self._log("error", str(e))
            logger.error(f"AI analysis failed: {e}")
            return {"enabled": False, "error": str(e), "message": error_msg}

    def _prepare_assignment_summary(
        self, assignments: List[Assignment], analysis_data: Dict[str, Any]
    ) -> str:
        """Prepare assignment summary for AI | ‰∏∫AIÂáÜÂ§á‰Ωú‰∏öÊëòË¶Å"""
        summary = []

        # Add basic statistics | Ê∑ªÂä†Âü∫Êú¨ÁªüËÆ°
        summary.append(f"Total assignments: {len(assignments)}")
        summary.append(f"Overdue: {analysis_data.get('overdue_count', 0)}")
        summary.append(f"Due this week: {analysis_data.get('due_this_week', 0)}")

        # Add priority distribution | Ê∑ªÂä†‰ºòÂÖàÁ∫ßÂàÜÂ∏É
        priority_dist = analysis_data.get("priority_distribution", {})
        summary.append(f"High priority: {priority_dist.get('high', 0)}")
        summary.append(f"Medium priority: {priority_dist.get('medium', 0)}")
        summary.append(f"Low priority: {priority_dist.get('low', 0)}")

        # Add course distribution | Ê∑ªÂä†ËØæÁ®ãÂàÜÂ∏É
        course_dist = analysis_data.get("course_distribution", {})
        summary.append(f"Courses with assignments: {len(course_dist)}")

        # Add assignment details | Ê∑ªÂä†‰Ωú‰∏öËØ¶ÊÉÖ
        summary.append("\nAssignment details:")
        for assignment in assignments[:10]:  # Limit to first 10 for API
            summary.append(
                f"- {assignment.title} ({assignment.course}): Due {assignment.due_date}"
            )

        return "\n".join(summary)

    def _generate_insights(self, assignment_summary: str) -> Dict[str, str]:
        """Generate AI insights | ÁîüÊàêAIÊ¥ûÂØü"""
        if not self.client:
            return {}

        try:
            prompt = f"""
            Based on the following assignment summary, provide insights in {self.language}:
            
            {assignment_summary}
            
            Please provide:
            1. Overall workload assessment
            2. Key challenges identified
            3. Recommended focus areas
            4. Risk factors to watch
            
            Format as JSON with keys: workload, challenges, focus_areas, risks
            """

            response = self.client.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are an educational assistant helping students manage their assignments.",
                    },
                    {"role": "user", "content": prompt},
                ],
                temperature=0.7,
                max_tokens=500,
            )

            content = response.choices[0].message.content

            # Try to parse JSON response | Â∞ùËØïËß£ÊûêJSONÂìçÂ∫î
            try:
                return json.loads(content)
            except (json.JSONDecodeError, TypeError):
                return {"analysis": content}

        except Exception as e:
            logger.error(f"Failed to generate insights: {e}")
            return {}

    def _generate_recommendations(
        self, assignment_summary: str, insights: Dict[str, str]
    ) -> List[str]:
        """Generate study recommendations | ÁîüÊàêÂ≠¶‰π†Âª∫ËÆÆ"""
        if not self.client:
            return []

        try:
            prompt = f"""
            Based on the assignment summary and insights, provide 5 actionable recommendations in {self.language}:
            
            Summary: {assignment_summary}
            Insights: {json.dumps(insights)}
            
            Provide practical, specific recommendations for managing these assignments effectively.
            Return as a JSON array of strings.
            """

            response = self.client.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are an educational assistant providing study recommendations.",
                    },
                    {"role": "user", "content": prompt},
                ],
                temperature=0.7,
                max_tokens=300,
            )

            content = response.choices[0].message.content

            try:
                return json.loads(content)
            except (json.JSONDecodeError, TypeError):
                return [content]

        except Exception as e:
            logger.error(f"Failed to generate recommendations: {e}")
            return []

    def _generate_time_plan(
        self, assignments: List[Assignment], analysis_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate time management plan | ÁîüÊàêÊó∂Èó¥ÁÆ°ÁêÜËÆ°Âàí"""
        if not self.client:
            return {}

        try:
            # Prepare assignment list for planning | ÂáÜÂ§áËÆ°ÂàíÁöÑ‰Ωú‰∏öÂàóË°®
            assignment_list = []
            for assignment in assignments[:10]:
                assignment_list.append(
                    {
                        "title": assignment.title,
                        "course": assignment.course,
                        "due_date": assignment.due_date,
                        "priority": analysis_data.get("priorities", {}).get(
                            assignment.title, "medium"
                        ),
                    }
                )

            prompt = f"""
            Create a time management plan in {self.language} for these assignments:
            {json.dumps(assignment_list, indent=2)}
            
            Provide:
            1. Daily schedule suggestions
            2. Priority order for completion
            3. Time allocation recommendations
            4. Break and rest periods
            
            Format as JSON with keys: daily_schedule, priority_order, time_allocation, breaks
            """

            response = self.client.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a time management expert helping students plan their work.",
                    },
                    {"role": "user", "content": prompt},
                ],
                temperature=0.7,
                max_tokens=500,
            )

            content = response.choices[0].message.content

            try:
                return json.loads(content)
            except (json.JSONDecodeError, TypeError):
                return {"plan": content}

        except Exception as e:
            logger.error(f"Failed to generate time plan: {e}")
            return {}

    def _generate_summary(
        self, insights: Dict[str, str], recommendations: List[str]
    ) -> str:
        """Generate executive summary | ÁîüÊàêÊâßË°åÊëòË¶Å"""
        if self.language == "zh":
            summary = "ü§ñ AIÂä©ÊâãÂàÜÊûêÊëòË¶Å\n\n"

            if insights:
                summary += "üìä ÂÖ≥ÈîÆÊ¥ûÂØüÔºö\n"
                for key, value in insights.items():
                    summary += f"‚Ä¢ {value}\n"

            if recommendations:
                summary += "\nüí° Âª∫ËÆÆË°åÂä®Ôºö\n"
                for i, rec in enumerate(recommendations[:5], 1):
                    summary += f"{i}. {rec}\n"
        else:
            summary = "ü§ñ AI Assistant Analysis Summary\n\n"

            if insights:
                summary += "üìä Key Insights:\n"
                for key, value in insights.items():
                    summary += f"‚Ä¢ {value}\n"

            if recommendations:
                summary += "\nüí° Recommended Actions:\n"
                for i, rec in enumerate(recommendations[:5], 1):
                    summary += f"{i}. {rec}\n"

        return summary

    def get_quick_suggestion(self, assignment: Assignment) -> str:
        """
        Get quick AI suggestion for a single assignment | Ëé∑ÂèñÂçï‰∏™‰Ωú‰∏öÁöÑÂø´ÈÄüAIÂª∫ËÆÆ

        Args:
            assignment: Assignment to analyze | Ë¶ÅÂàÜÊûêÁöÑ‰Ωú‰∏ö

        Returns:
            Quick suggestion string | Âø´ÈÄüÂª∫ËÆÆÂ≠óÁ¨¶‰∏≤
        """
        if not self.enable_ai or not self.client:
            return ""

        try:
            prompt = f"""
            Provide a brief suggestion in {self.language} for this assignment:
            Title: {assignment.title}
            Course: {assignment.course}
            Due: {assignment.due_date}
            
            Give one concise, actionable tip (max 50 words).
            """

            response = self.client.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a helpful study assistant."},
                    {"role": "user", "content": prompt},
                ],
                temperature=0.7,
                max_tokens=100,
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            logger.error(f"Failed to get quick suggestion: {e}")
            return ""
